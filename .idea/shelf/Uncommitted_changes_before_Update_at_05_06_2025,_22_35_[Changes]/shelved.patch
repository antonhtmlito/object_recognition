Index: roboSim.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\n\nfrom robodetectíon import getBotPosition\n\nimport pygame\nimport numpy as np\nimport cv2\nimport math\nfrom robodetectíon import getBotPosition\nfrom detect_white_and_yellow_ball import get_ball_positions\nfrom roboController import RoboController\nimport routing_functions\n\n# Pygame setup\npygame.init()\nscreen = pygame.display.set_mode((1920, 1080))\nclock = pygame.time.Clock()\nrunning = True\n\n# Update interval\nlast_update_time = time.time()\nupdate_interval = 0.1  # seconds\n\n# Load image\nfile = \"obstacle_mask.png\"\nloaded_mask = cv2.imread(file, cv2.IMREAD_COLOR)\n\n# Convert to RGBA and set alpha\nloaded_mask_rgba = cv2.cvtColor(loaded_mask, cv2.COLOR_BGR2RGBA)\nloaded_mask_rgba[:, :, 3] = np.where(\n    (loaded_mask_rgba[:, :, 0:3] == [0,0,0]).all(axis=2),\n    0,  # Transparent\n    255  # Opaque\n)\n\nalpha_channel = np.where(\n    (loaded_mask_rgba[:, :, 0:3] == [0, 0, 0]).all(axis=2),\n    0,  # Transparent\n    255  # Opaque\n)\n# Binary obstacle mask\nobstacle_mask = alpha_channel > 0\n\n\n# Create Pygame surface\nheight, width = loaded_mask.shape[:2]\nmask_surface = pygame.image.frombuffer(\n    loaded_mask_rgba.tobytes(),\n    (width, height),\n    'RGBA'\n).convert_alpha()\n\n# Global variables predefined\nplayer = {\n    \"x\": 0,\n    \"y\": 0,\n    \"rotation\": 0,\n    \"width\": 30,\n    \"height\": 50,\n    }\nobstacle = {\n    \"x\": 0,\n    \"y\": 0,\n}\ntargets = {\n    \"list\": []\n}\n\nroboController = RoboController()\n\n\ndef cast_rays(player, max_distance=700):\n    start_angle = player[\"rotation\"]\n    start_x = player[\"x\"]\n    start_y = player[\"y\"]\n\n    for i in range(-5, 5):\n        start_x = player[\"x\"] + math.cos(start_angle) * i * 6\n        start_y = player[\"y\"] - math.sin(start_angle) * i * 6\n\n        for pixel in range(max_distance):\n            target_x = int(start_x + math.sin(start_angle) * pixel)\n            target_y = int(start_y + math.cos(start_angle) * pixel)\n            if 0 <= target_x < alpha_channel.shape[1] and 0 <= target_y < alpha_channel.shape[0]:\n                if alpha_channel[target_y][target_x] > 0:\n                    print(alpha_channel[target_y][target_x])\n                    print(\"found\")\n                    print(target_x)\n                    print(target_y)\n                    break\n\n        pygame.draw.line(screen, (255, 50, 50), (start_x, start_y), (target_x, target_y))\n\n\ncap = cv2.VideoCapture(0)\nif not cap.isOpened():\n    raise Exception(\"camera not openened\")\n\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            mouse_x, mouse_y = pygame.mouse.get_pos()\n            routing_functions.all_targets.append((mouse_x, mouse_y))\n            routing_functions.calculate_target()\n        if event.type == pygame.K_UP:\n            running = False\n            print(\"forward\")\n\n    botPos = getBotPosition(cap)\n    print(botPos)\n    if botPos is not None:\n        player[\"x\"] = botPos[\"position\"][0]\n        player[\"y\"] = botPos[\"position\"][1]\n        player[\"rotation\"] = botPos[\"angle\"]\n\n    ball_positions = get_ball_positions(cap)\n\n    screen.fill(\"black\")\n    screen.blit(mask_surface, (0, 0))\n\n    for color_name, coords in ball_positions.items():\n        # decide Pygame color by inspecting the HSV‐based name\n        if \"white\" in color_name.lower():\n            py_color = (255, 255, 255)\n        elif \"orange\" in color_name.lower():\n            py_color = (0, 140, 255)\n        else:\n            py_color = (200, 200, 200)\n\n        for (bx, by) in coords:\n            pygame.draw.circle(screen, py_color, (bx, by), 8)\n\n    # Draw player\n    # Create base player surface\n    player_surface = pygame.Surface((player[\"width\"], player[\"height\"]), pygame.SRCALPHA)\n    pygame.draw.rect(player_surface, \"blue\", player_surface.get_rect())\n\n# Update data\n    current_time = time.time()\n    if current_time - last_update_time > update_interval:\n        routing_functions.update_robot_state(player)\n        routing_functions.update_obstacle_state(obstacle)\n        # update_targets_state(targets)\n        last_update_time = current_time\n\n# Draw targets\n    for tx, ty in routing_functions.all_targets:\n        pygame.draw.circle(screen, \"red\", (tx, ty), 8)\n\n# Remove targets\n    if routing_functions.target_x is not None and routing_functions.target_y is not None:\n        if abs(routing_functions.robot_x - routing_functions.target_x) < 50 and abs(routing_functions.robot_y - routing_functions.target_y) < 50:\n            if (routing_functions.target_x, routing_functions.target_y) in routing_functions.all_targets:\n                routing_functions.all_targets.remove((routing_functions.target_x, routing_functions.target_y))\n            routing_functions.calculate_target()\n\n# Drive to target\n    angle_to_turn = routing_functions.calculate_angle(routing_functions.target_x, routing_functions.target_y)\n    print(\"angle to turn: \", angle_to_turn)\n    print(\"targets:\", routing_functions.target_x, routing_functions.target_y)\n    if angle_to_turn is None:\n        pass\n    elif angle_to_turn > 5:\n        roboController.rotate_clockwise(angle_to_turn)\n        time.sleep(0.05)\n    elif angle_to_turn < -5:\n        roboController.rotate_counterClockwise(abs(angle_to_turn))\n        time.sleep(0.05)\n    else:\n        distance = routing_functions.calculate_distance(routing_functions.target_x, routing_functions.target_y)\n        if distance > 5:\n            roboController.forward(0.5)\n            time.sleep(0.05)\n\n# Rotate the surface around its center\n    rotated_surface = pygame.transform.rotate(player_surface, math.degrees(player[\"rotation\"]))\n    rotated_rect = rotated_surface.get_rect(center=(player[\"x\"], player[\"y\"]))\n\n# Draw the rotated player\n    screen.blit(rotated_surface, rotated_rect.topleft)\n    cast_rays(player, max_distance=500)\n\n    keys = pygame.key.get_pressed()\n\n    if keys[pygame.K_LEFT]:\n        roboController.rotate_counterClockwise(10)\n#        player[\"rotation\"] = player[\"rotation\"] - 0.01\n    elif keys[pygame.K_RIGHT]:\n        roboController.rotate_clockwise(10)\n#        player[\"rotation\"] = player[\"rotation\"] + 0.01\n    elif keys[pygame.K_UP]:\n        roboController.forward(2)\n#    elif keys[pygame.K_DOWN]:\n\n    pygame.display.flip()\n    clock.tick(60)\n\npygame.quit()\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/roboSim.py b/roboSim.py
--- a/roboSim.py	(revision e4ac1662a66e334a289ec4a25a50ada56a1dbd0c)
+++ b/roboSim.py	(date 1749127593860)
@@ -13,7 +13,7 @@
 
 # Pygame setup
 pygame.init()
-screen = pygame.display.set_mode((1920, 1080))
+screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
 clock = pygame.time.Clock()
 running = True
 
