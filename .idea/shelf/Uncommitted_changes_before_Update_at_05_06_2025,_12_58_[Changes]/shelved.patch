Index: roboSim.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\n\nfrom robodetectíon import getBotPosition\n\nimport pygame\nimport numpy as np\nimport cv2\nimport math\nfrom robodetectíon import getBotPosition\nfrom detect_white_and_yellow_ball import get_ball_positions\nfrom roboController import RoboController\nfrom routing_functions import update_robot_state, update_obstacle_state, update_targets_state, calculate_target, calculate_distance, calculate_angle, is_path_blocked, find_detour\n\n# Pygame setup\npygame.init()\nscreen = pygame.display.set_mode((1920, 1080))\nclock = pygame.time.Clock()\nrunning = True\n\n# Update interval\nlast_update_time = time.time()\nupdate_interval = 0.5  # seconds\n\n# Load image\nfile = \"obstacle_mask.png\"\nloaded_mask = cv2.imread(file, cv2.IMREAD_COLOR)\n\n# Convert to RGBA and set alpha\nloaded_mask_rgba = cv2.cvtColor(loaded_mask, cv2.COLOR_BGR2RGBA)\nloaded_mask_rgba[:, :, 3] = np.where(\n    (loaded_mask_rgba[:, :, 0:3] == [0,0,0]).all(axis=2),\n    0,  # Transparent\n    255  # Opaque\n)\n\nalpha_channel = np.where(\n    (loaded_mask_rgba[:, :, 0:3] == [0, 0, 0]).all(axis=2),\n    0,  # Transparent\n    255  # Opaque\n)\n# Binary obstacle mask\nobstacle_mask = alpha_channel > 0\n\n\n# Create Pygame surface\nheight, width = loaded_mask.shape[:2]\nmask_surface = pygame.image.frombuffer(\n    loaded_mask_rgba.tobytes(),\n    (width, height),\n    'RGBA'\n).convert_alpha()\n\n# Global variables predefined\nplayer = {\n    \"x\": 0,\n    \"y\": 0,\n    \"rotation\": 0,\n    \"width\": 0,\n    \"height\": 0\n    }\nobstacle = {\n    \"x\": 0,\n    \"y\": 0,\n}\ntargets = {\n    \"list\": []\n}\nrobot_x = 0\nrobot_y = 0\nrobot_angle = 0\nobstacle_x = 0\nobstacle_y = 0\ntarget_x = 200\ntarget_y = 200\nall_targets = []\n\nroboController = RoboController()\n\n\ndef cast_rays(player, max_distance=700):\n    start_angle = player[\"rotation\"]\n    start_x = player[\"x\"]\n    start_y = player[\"y\"]\n\n    for i in range(-5,5):\n        start_x = player[\"x\"] + math.cos(start_angle) * i * 6\n        start_y = player[\"y\"] - math.sin(start_angle) * i * 6\n\n        for pixel in range(max_distance):\n            target_x = int(start_x + math.sin(start_angle) * pixel)\n            target_y = int(start_y + math.cos(start_angle) * pixel)\n            if 0 <= target_x < alpha_channel.shape[1] and 0 <= target_y < alpha_channel.shape[0]:\n                if alpha_channel[target_y][target_x] > 0:\n                    print(alpha_channel[target_y][target_x])\n                    print(\"found\")\n                    print(target_x)\n                    print(target_y)\n                    break\n\n        pygame.draw.line(screen, (255, 50, 50), (start_x, start_y), (target_x, target_y))\n\n\ncap = cv2.VideoCapture(0)\nif not cap.isOpened():\n    raise Exception(\"camera not openened\")\n\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.K_UP:\n            running = False\n            print(\"forward\")\n\n    botPos = getBotPosition(cap)\n    print(botPos)\n    if botPos is not None:\n        player[\"x\"] = botPos[\"position\"][0]\n        player[\"y\"] = botPos[\"position\"][1]\n        player[\"rotation\"] = botPos[\"angle\"]\n\n    ball_positions = get_ball_positions(cap)\n\n    screen.fill(\"black\")\n    screen.blit(mask_surface, (0, 0))\n\n    for color_name, coords in ball_positions.items():\n        # decide Pygame color by inspecting the HSV‐based name\n        if \"white\" in color_name.lower():\n            py_color = (255, 255, 255)\n        elif \"orange\" in color_name.lower():\n            py_color = (0, 140, 255)\n        else:\n            py_color = (200, 200, 200)\n\n        for (bx, by) in coords:\n            pygame.draw.circle(screen, py_color, (bx, by), 8)\n\n    # Draw player\n    # Create base player surface\n    player_surface = pygame.Surface((player[\"width\"], player[\"height\"]), pygame.SRCALPHA)\n    pygame.draw.rect(player_surface, \"blue\", player_surface.get_rect())\n\n# Update data\n    current_time = time.time()\n    if current_time - last_update_time > update_interval:\n        update_robot_state(player)\n        update_obstacle_state(obstacle)\n        # update_targets_state(targets)\n        last_update_time = current_time\n\n    pygame.draw.circle(screen, \"red\", (target_x, target_y), 8)\n\n# Drive to target\n    angle_to_turn = calculate_angle(target_x, target_y)\n    print(\"angle to turn: \", angle_to_turn)\n    if angle_to_turn is None:\n        pass\n    elif angle_to_turn > 5:\n        roboController.rotate_clockwise(5)\n        time.sleep(1)\n    elif angle_to_turn < -5:\n        roboController.rotate_counterClockwise(5)\n        time.sleep(1)\n    else:\n        distance = calculate_distance(target_x, target_y)\n        if distance > 5:\n            roboController.forward(0.5)\n\n# Rotate the surface around its center\n    rotated_surface = pygame.transform.rotate(player_surface, math.degrees(player[\"rotation\"]))\n    rotated_rect = rotated_surface.get_rect(center=(player[\"x\"], player[\"y\"]))\n\n# Draw the rotated player\n    screen.blit(rotated_surface, rotated_rect.topleft)\n    cast_rays(player, max_distance=500)\n\n    keys = pygame.key.get_pressed()\n\n    if keys[pygame.K_LEFT]:\n        roboController.rotate_counterClockwise(10)\n#        player[\"rotation\"] = player[\"rotation\"] - 0.01\n    elif keys[pygame.K_RIGHT]:\n        roboController.rotate_clockwise(10)\n#        player[\"rotation\"] = player[\"rotation\"] + 0.01\n    elif keys[pygame.K_UP]:\n        roboController.forward(2)\n#    elif keys[pygame.K_DOWN]:\n\n    pygame.display.flip()\n    clock.tick(60)\n\npygame.quit()\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/roboSim.py b/roboSim.py
--- a/roboSim.py	(revision e1bd769f7ae646a6e2a5c1f4584f1cf4d94027b0)
+++ b/roboSim.py	(date 1749120998521)
@@ -19,7 +19,7 @@
 
 # Update interval
 last_update_time = time.time()
-update_interval = 0.5  # seconds
+update_interval = 0.1  # seconds
 
 # Load image
 file = "obstacle_mask.png"
@@ -109,6 +109,11 @@
     for event in pygame.event.get():
         if event.type == pygame.QUIT:
             running = False
+        if event.type == pygame.MOUSEBUTTONDOWN:
+            mouse_x, mouse_y = pygame.mouse.get_pos()
+            calculate_target()
+            all_targets = ([mouse_x, mouse_y],)
+            update_targets_state(all_targets)
         if event.type == pygame.K_UP:
             running = False
             print("forward")
@@ -150,7 +155,8 @@
         # update_targets_state(targets)
         last_update_time = current_time
 
-    pygame.draw.circle(screen, "red", (target_x, target_y), 8)
+    for tx, ty in all_targets:
+        pygame.draw.circle(screen, "red", (tx, ty), 8)
 
 # Drive to target
     angle_to_turn = calculate_angle(target_x, target_y)
@@ -159,10 +165,10 @@
         pass
     elif angle_to_turn > 5:
         roboController.rotate_clockwise(5)
-        time.sleep(1)
+        time.sleep(0.5)
     elif angle_to_turn < -5:
         roboController.rotate_counterClockwise(5)
-        time.sleep(1)
+        time.sleep(0.5)
     else:
         distance = calculate_distance(target_x, target_y)
         if distance > 5:
Index: routing_functions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import math\n\nrobot_x = 0\nrobot_y = 0\nrobot_angle = 0\nobstacle_x = 0\nobstacle_y = 0\ntarget_x = 100\ntarget_y = 100\n# Robot state\ndef update_robot_state(player):\n    global robot_x, robot_y, robot_angle\n    robot_x = player[\"x\"]\n    robot_y = player[\"y\"]\n    robot_angle = (player[\"rotation\"])\n\n# Obstacle state\ndef update_obstacle_state(obstacle):\n    global obstacle_x, obstacle_y\n    obstacle_x = obstacle[\"x\"]\n    obstacle_y = obstacle[\"y\"]\n\n# Target state\ndef update_targets_state(targets):\n    global all_targets\n    all_targets = targets\n\n# Calculate closest target\ndef calculate_target():\n    global target_x, target_y\n\n    if not all_targets:\n        target_x, target_y = None, None\n        return target_x, target_y\n\n    closest_target = None\n    min_distance = float('inf')\n\n    for tx, ty in all_targets:\n        distance = calculate_distance(tx, ty)\n        if distance < min_distance:\n            min_distance = distance\n            closest_target = (tx, ty)\n\n    if closest_target:\n        tx, ty = closest_target\n    else:\n        tx, ty = None, None\n\n    target_x, target_y = tx, ty\n    return target_x, target_y\n\n# Check for whether the path is blocked\ndef is_path_blocked(target_x, target_y, threshold=60):\n    distance_to_line = abs((target_y - robot_y) * obstacle_x - (target_x - robot_x) * obstacle_y + target_x * robot_y - target_y * robot_x) / math.hypot(target_x - robot_x, target_y - robot_y)\n    return distance_to_line < threshold and min(robot_x, target_x) < obstacle_x < max(robot_x, target_x)\n\n# Calculate simple detour point\ndef find_detour( detour_distance=100):\n    obstacle_angle = math.atan2(obstacle_y - robot_y, obstacle_x - robot_x)\n    detour_angle = obstacle_angle + math.radians(90)\n    detour_x = obstacle_x + detour_distance * math.cos(detour_angle)\n    detour_y = obstacle_y + detour_distance * math.sin(detour_angle)\n    return detour_x, detour_y\n\n# Angle from robot to target\ndef calculate_angle(target_x, target_y):\n    if target_x is None or target_y is None:\n        return None\n    angle_to_target = math.degrees(math.atan2(target_y - robot_y, target_x - robot_x))\n    angle_difference = (angle_to_target - math.degrees(robot_angle) + 360) % 360\n    return angle_difference if angle_difference <= 180 else angle_difference - 360\n\n# Distance from robot to target\ndef calculate_distance(target_x, target_y):\n    distance_to_target = math.sqrt((target_x - robot_x) ** 2 + (target_y - robot_y) ** 2)\n    return distance_to_target\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/routing_functions.py b/routing_functions.py
--- a/routing_functions.py	(revision e1bd769f7ae646a6e2a5c1f4584f1cf4d94027b0)
+++ b/routing_functions.py	(date 1749120936541)
@@ -5,8 +5,9 @@
 robot_angle = 0
 obstacle_x = 0
 obstacle_y = 0
-target_x = 100
-target_y = 100
+target_x = 300
+target_y = 300
+all_targets = []
 # Robot state
 def update_robot_state(player):
     global robot_x, robot_y, robot_angle
